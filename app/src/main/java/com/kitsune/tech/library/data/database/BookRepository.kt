package com.kitsune.tech.library.data.database

import com.kitsune.tech.library.data.api.RetrofitInstance
import com.kitsune.tech.library.data.api.models.BookDoc
import com.kitsune.tech.library.data.api.models.WorkDetails
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext

class BookRepository(private val bookDao: BookDao) {
    private val api = RetrofitInstance.api

    // Local database operations
    suspend fun insertBooks(books: List<Book>) = bookDao.insertBooks(books)

    suspend fun getBookById(bookId: Int): Book? = bookDao.getBookById(bookId)

    suspend fun getAllBooks(): List<Book> = bookDao.getAllBooks()

    suspend fun searchBooks(query: String): List<Book> = bookDao.searchBooks(query)

    // API operations
    suspend fun searchBooksFromApi(query: String, limit: Int = 20, persist: Boolean = true): Result<List<Book>> = withContext(Dispatchers.IO) {
        try {
            val response = api.searchBooks(query = query, limit = limit)
            val books = response.docs.mapNotNull { it.toBook() }

            // Persist to local database for offline access
            if (persist && books.isNotEmpty()) {
                insertBooks(books)
            }

            Result.success(books)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    suspend fun getPopularBooks(subject: String = "fiction", limit: Int = 20, persist: Boolean = true): Result<List<Book>> = withContext(Dispatchers.IO) {
        try {
            val response = api.searchBooksBySubject(subject = subject, limit = limit)
            val books = response.docs.mapNotNull { it.toBook() }

            // Persist to local database for offline access
            if (persist && books.isNotEmpty()) {
                insertBooks(books)
            }

            Result.success(books)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    suspend fun getBooksByAuthor(author: String, limit: Int = 20, persist: Boolean = true): Result<List<Book>> = withContext(Dispatchers.IO) {
        try {
            val response = api.searchBooksByAuthor(author = author, limit = limit)
            val books = response.docs.mapNotNull { it.toBook() }

            // Persist to local database for offline access
            if (persist && books.isNotEmpty()) {
                insertBooks(books)
            }

            Result.success(books)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    suspend fun getWorkDetails(workId: String): Result<WorkDetails> = withContext(Dispatchers.IO) {
        try {
            val work = api.getWorkDetails(workId)
            Result.success(work)
        } catch (e: Exception) {
            Result.failure(e)
        }
    }

    // Helper function to convert BookDoc to Book entity
    private fun BookDoc.toBook(): Book? {
        val title = this.title ?: return null
        val author = this.authorName?.firstOrNull() ?: "Unknown Author"
        val coverUrl = this.getCoverUrl("L")
        val genre = this.subjects?.firstOrNull() ?: "General"

        return Book(
            id = 0, // Will be auto-generated by Room
            title = title,
            author = author,
            description = "Published in ${this.firstPublishYear ?: "Unknown"}",
            genre = genre,
            coverImageUrl = coverUrl ?: "",
            publishedYear = this.firstPublishYear ?: 0,
            totalPages = this.numberOfPages ?: 0,
            rating = this.ratingsAverage?.toFloat() ?: 0f,
            addedAt = System.currentTimeMillis()
        )
    }

    // Helper function to convert WorkDetails to Book entity
    fun WorkDetails.toBook(): Book? {
        val title = this.title ?: return null
        val coverUrl = this.getCoverUrl("L")
        val genre = this.subjects?.firstOrNull() ?: "General"
        val description = this.getDescriptionText() ?: "No description available"

        return Book(
            id = 0,
            title = title,
            author = "Unknown Author", // Will need to fetch author details separately
            description = description,
            genre = genre,
            coverImageUrl = coverUrl ?: "",
            publishedYear = this.firstPublishDate?.take(4)?.toIntOrNull() ?: 0,
            totalPages = 0,
            rating = 0f,
            addedAt = System.currentTimeMillis()
        )
    }

    // Combined search: API first, fallback to local
    suspend fun searchBooksHybrid(query: String): List<Book> {
        val apiResult = searchBooksFromApi(query)
        return if (apiResult.isSuccess) {
            apiResult.getOrNull() ?: emptyList()
        } else {
            searchBooks(query) // Fallback to local search
        }
    }
}
